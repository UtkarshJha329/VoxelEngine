
#version 460 core

layout (local_size_x = 512) in;

struct Plane {
    vec3 normal;
    vec3 pointOnPlane;
};

struct Frustum
{
	Plane nearPlane;

	Plane rightPlane;
	Plane leftPlane;

	Plane topPlane;
	Plane bottomPlane;
};


layout (binding = 6, std430) buffer CameraFrustumData {
	Frustum cameraFrustumData;
};

layout (binding = 7, std430) buffer ChunksVisibilityData {
	int chunksVisibilityData[];
};

uniform vec3 cameraPosition;
uniform vec3 cameraPointingDirectionNormalised;
uniform vec3 worldSizeInChunks;

bool PointInDirectionPlaneIsPointingIn(vec3 point, Plane plane){
    return dot((point - plane.pointOnPlane), plane.normal) >= 0;
}

bool DoesChunkLieOnOrInFrustum(vec3 chunkPos, vec3 chunkSizeInVoxels, Frustum curFrustum){
    
    vec3 a = chunkPos;
    vec3 b = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y, chunkPos.z);
    vec3 c = vec3(chunkPos.x, chunkPos.y, chunkPos.z + chunkSizeInVoxels.z);
    vec3 d = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y, chunkPos.z + chunkSizeInVoxels.z);

    vec3 e = chunkPos + vec3(0, chunkSizeInVoxels.y, 0);
    vec3 f = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z);
    vec3 g = vec3(chunkPos.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z + chunkSizeInVoxels.z);
    vec3 h = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z + chunkSizeInVoxels.z);

    vec3 chunkBoundingPoints[8] = {a, b, c, d, e, f, g, h};
    Plane allFrustumPlanes[5] = {curFrustum.nearPlane,
                                 curFrustum.rightPlane,
                                 curFrustum.leftPlane,
                                 curFrustum.topPlane,
                                 curFrustum.bottomPlane};

    for(int planeIndex = 0; planeIndex < 4; planeIndex++){
        bool allEightPointsBehindPlane = true;
        for(int chunkPointIndex = 0; chunkPointIndex < 8; chunkPointIndex++){
            if (PointInDirectionPlaneIsPointingIn(chunkBoundingPoints[chunkPointIndex], allFrustumPlanes[planeIndex])){
                allEightPointsBehindPlane = false;
                break;
            }
        }
        if (allEightPointsBehindPlane == true){
            return false;
        }
    }

    return true;
}


void main(void) {

	if (gl_GlobalInvocationID.x >= (worldSizeInChunks.x * worldSizeInChunks.y * worldSizeInChunks.z)) {
		return;
	}

    vec3 chunkSizeInVoxels = vec3(32.0, 32.0, 32.0);
    
    float chunkYIndex = gl_GlobalInvocationID.x / (worldSizeInChunks.x * worldSizeInChunks.z);
    float rem = mod(gl_GlobalInvocationID.x, (worldSizeInChunks.x * worldSizeInChunks.z));

    float chunkZIndex = rem / worldSizeInChunks.x;
    float chunkXIndex = mod(rem, worldSizeInChunks.x);

    vec3 chunkPos = vec3(chunkXIndex, chunkYIndex, chunkZIndex) * chunkSizeInVoxels;

    if (DoesChunkLieOnOrInFrustum(chunkPos, chunkSizeInVoxels, cameraFrustumData)){
        chunksVisibilityData[gl_GlobalInvocationID.x] = 1;
    } else {
        chunksVisibilityData[gl_GlobalInvocationID.x] = 0;
    }
}

