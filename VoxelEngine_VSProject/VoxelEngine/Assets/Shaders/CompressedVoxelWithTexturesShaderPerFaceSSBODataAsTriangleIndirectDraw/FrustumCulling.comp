
#version 460 core

layout (local_size_x = 512) in;

struct Plane {
    vec3 normal;
    vec3 pointOnPlane;
};

struct Frustum
{
	Plane nearPlane;

	Plane rightPlane;
	Plane leftPlane;

	Plane topPlane;
	Plane bottomPlane;
};


layout (binding = 6, std430) buffer CameraFrustumData {
	Frustum cameraFrustumData;
};

layout (binding = 7, std430) buffer ChunksVisibilityData {
	int chunksVisibilityData[];
};

uniform vec3 cameraPosition;
uniform vec3 cameraPointingDirectionNormalised;
uniform vec3 worldSizeInChunks;
uniform vec3 chunkSizeInVoxels;

bool PointInDirectionPlaneIsPointingIn(vec3 point, Plane plane){
    return dot((point - plane.pointOnPlane), plane.normal) >= 0;
}

bool DoesChunkLieOnOrInFrustum(vec3 chunkPos, vec3 chunkSizeInVoxels, Frustum curFrustum){
    
    vec3 a = chunkPos;
    vec3 b = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y, chunkPos.z);
    vec3 c = vec3(chunkPos.x, chunkPos.y, chunkPos.z + chunkSizeInVoxels.z);
    vec3 d = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y, chunkPos.z + chunkSizeInVoxels.z);

    vec3 e = chunkPos + vec3(0, chunkSizeInVoxels.y, 0);
    vec3 f = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z);
    vec3 g = vec3(chunkPos.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z + chunkSizeInVoxels.z);
    vec3 h = vec3(chunkPos.x + chunkSizeInVoxels.x, chunkPos.y + chunkSizeInVoxels.y, chunkPos.z + chunkSizeInVoxels.z);

    vec3 chunkBoundingPoints[8] = {a, b, c, d, e, f, g, h};
    Plane allFrustumPlanes[5] = {curFrustum.nearPlane,
                                 curFrustum.rightPlane,
                                 curFrustum.leftPlane,
                                 curFrustum.topPlane,
                                 curFrustum.bottomPlane};

    for(int planeIndex = 0; planeIndex < 4; planeIndex++){
        bool allEightPointsBehindPlane = true;
        for(int chunkPointIndex = 0; chunkPointIndex < 8; chunkPointIndex++){
            if (PointInDirectionPlaneIsPointingIn(chunkBoundingPoints[chunkPointIndex], allFrustumPlanes[planeIndex])){
                allEightPointsBehindPlane = false;
                break;
            }
        }
        if (allEightPointsBehindPlane == true){
            return false;
        }
    }

    return true;
}

bool DoesChunkLieOnOrInFrustumPVertex(vec3 chunkPos, vec3 chunkSizeInVoxels, Frustum curFrustum) {

    // Code from gemini
    // It checks if the closest point on the box to the camera is hidden behind the plane or not.

    // 1. Pre-calculate Center and Extent (Do this once per chunk, or deduce it here)
    vec3 extent = chunkSizeInVoxels * 0.5f;
    vec3 center = chunkPos + extent;

    // 2. Load planes into an array for easy unrolling (or keep them separate)
    // Note: Usually we store planes as vec4(normal.x, normal.y, normal.z, distance) for speed.
    // Here I adapt to your struct.
    const Plane planes[5] = {
        curFrustum.nearPlane, 
        curFrustum.rightPlane, 
        curFrustum.leftPlane, 
        curFrustum.topPlane, 
        curFrustum.bottomPlane
    };

    // 3. Iterate Planes
    for (int i = 0; i < 5; i++) {
        const Plane p = planes[i];

        // TRANSFORM PLANE:
        // Standard plane equation: dot(point, normal) + d = 0
        // Your plane has a point, so d = -dot(p.pointOnPlane, p.normal)
        // You should pre-calculate 'd' for your frustum planes once per frame!
        float d = -dot(p.pointOnPlane, p.normal);

        // A. Distance from plane to box center
        float distToCenter = dot(center, p.normal) + d;

        // B. Projected Radius (The size of the box along the normal)
        // We use abs() because we want the maximum extent in the direction of the normal
        float radius = dot(extent, abs(p.normal));

        // C. The Test
        // If the center is behind the plane by more than the radius, it's culled.
        if (distToCenter + radius < 0.0f) {
            return false; // Behind this plane
        }
    }

    return true; // Visible (or intersecting)
}


void main(void) {

	if (gl_GlobalInvocationID.x >= (worldSizeInChunks.x * worldSizeInChunks.y * worldSizeInChunks.z)) {
		return;
	}
    
    float chunkYIndex = gl_GlobalInvocationID.x / (worldSizeInChunks.x * worldSizeInChunks.z);
    float rem = mod(gl_GlobalInvocationID.x, (worldSizeInChunks.x * worldSizeInChunks.z));

    float chunkZIndex = rem / worldSizeInChunks.x;
    float chunkXIndex = mod(rem, worldSizeInChunks.x);

    vec3 chunkPos = vec3(chunkXIndex, chunkYIndex, chunkZIndex) * chunkSizeInVoxels;

    if (DoesChunkLieOnOrInFrustum(chunkPos, chunkSizeInVoxels, cameraFrustumData)){
//    if (DoesChunkLieOnOrInFrustumPVertex(chunkPos, chunkSizeInVoxels, cameraFrustumData)){
//    if (DoesChunkLieOnOrInFrustumPVertex(chunkPos - vec3(16), chunkSizeInVoxels + vec3(32), cameraFrustumData)){
        chunksVisibilityData[gl_GlobalInvocationID.x] = 1;
    } else {
        chunksVisibilityData[gl_GlobalInvocationID.x] = 0;
    }
}